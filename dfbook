#!/usr/bin/python3

import sys, struct
import json

NEW_LINE = 0x00
SAME_LINE = 0x01
POSITION_PREFIX = 0xfb
FONT_PREFIX = 0xf9
FONT_SCRIPT = 0x02
FONT_NORMAL = 0x04
END_PAGE = 0xf6
CENTER = 0xfd

class Line:
    """The content and formatting data for a single line of text."""

    def __init__(self, prev = None):
        self.align = 'left'
        if prev:
            self.font = prev.font
        else:
            self.font = 'normal'
        self.text = ''
        self.xpos = 0
        self.ypos = 0

    def as_dict(self):
        """Convert to a dictionary, for easy JSON converesion."""
        return {'align': self.align,
                'font': self.font,
                'xpos': self.xpos,
                'ypos': self.ypos,
                'text': self.text}

class Page:
    """A page from a book.

    Books in Daggerfall are divided into pages.  If text goes off a
    page, it will not automatically go onto another page.  Instead, it
    will just go off the screen.

    """

    def __init__(self, data, offset):
        self.lines = []

        i = offset
        line = Line()

        while data[i] != END_PAGE:
            if data[i + 1] == POSITION_PREFIX:
                if data[i] == NEW_LINE:
                    self.lines.append(line)
                    line = Line(line)
                    line.xpos = data[i + 2]
                    line.ypos = data[i + 3]
                i += 4
                continue
            elif data[i] == FONT_PREFIX:
                if data[i + 1] == FONT_SCRIPT:
                    line.font = 'script'
                else:
                    line.font = 'normal'
                i += 2
                continue
            elif data[i] == NEW_LINE:
                self.lines.append(line)
                line = Line(line)
            elif data[i] == CENTER:
                line.align = 'center'
            else:
                line.text += chr(data[i])
            i+= 1

        if line.text != '':
            self.lines.append(line)

    def serializable(self):
        """Return the data in a way that can be converted to JSON."""
        cur_line = None
        line_list = []

        for line in self.lines:
            if cur_line:
                if (cur_line['align'] == line.align and
                    cur_line['font'] == line.font and
                    cur_line['xpos'] == line.xpos and
                    cur_line['ypos'] == line.ypos):

                    if not isinstance(cur_line['text'], list):
                        cur_line['text'] = [cur_line['text']]

                    cur_line['text'].append(line.text)
                else:
                    line_list.append(cur_line)
                    cur_line = line.as_dict()
            else:
                cur_line = line.as_dict()

        if cur_line:
            line_list.append(cur_line)

        return line_list

class Book:
    """Represents a single book and its contents

    The Book class contains all the text and formatting of one book,
    along with methods for writing and reading that information
    to/from various formats.

    """

    def __init__(self):
        self.title = ""
        self.author = ""
        self.pages = []
        self.naughty = False
        self.price = 0
        self.unknowns = [0, 0, 0]

    def decode(self, in_file):
        """Decode a file in the original book format

        in_file must be a file object or at least something with a
        .read() method which returns all the data as bytes.  Files
        must be opened in binary mode, or there will be unicode errors
        when trying to read from them.

        """
        book_data = in_file.read()

        if len(book_data) < 238:
            sys.stderr.write("Error: file too short\n")
            sys.exit(1)

        self.title = book_data[:64].decode('utf-8').rstrip('\0')
        self.author = book_data[64:128].decode('utf-8').rstrip('\0')

        self.naughty = book_data[128:136] == b'naughty '
        self.price = struct.unpack('<I', book_data[224:228])[0]

        self.unknowns = list(struct.unpack('<HHH', book_data[228:234]))

        page_count = struct.unpack('<H', book_data[234:236])[0]

        page_offsets = [struct.unpack('<I', book_data[236 + 4 * i:
                                                      240 + 4 * i])[0]
                        for i in range(page_count)]

        for offset in page_offsets:
            self.pages.append(Page(book_data, offset))

    def print_text(self):
        """Print as plain text, losing some formatting"""
        for p in self.pages:
            for l in p.lines:
                print(l.text)

    def dump_json(self):
        """Return all the book data in JSON format"""
        book_dict = {}
        book_dict['title'] = self.title
        book_dict['author'] = self.author
        book_dict['pages'] = [p.serializable() for p in self.pages]
        book_dict['naughty'] = self.naughty
        book_dict['price'] = self.price
        book_dict['unknowns'] = self.unknowns

        return json.dumps(book_dict, indent = 4)

def usage(status = 0):
    sys.stderr.write("Usage: book [FILE]\n")
    sys.exit(status)

if len(sys.argv) == 1:
    usage()
if len(sys.argv) > 3:
    sys.stderr.write("Error: wrong number of arguments\n")
    usage(1)

book = Book()

if len(sys.argv) == 3:
    try:
        in_file = open(sys.argv[2], 'rb')
    except IOError:
        sys.stderr.write("Error: could not open file {filename}\n"
                         .format(filename=sys.argv[2]))
        usage(1)
else:
    in_file = sys.stdin.buffer

if sys.argv[1] == "print":
    book.decode(in_file)
    book.print_text()
elif sys.argv[1] == "dump":
    book.decode(in_file)
    print(book.dump_json())
else:
    sys.stderr.write("Error: unknown verb '{verb}'\n"
                     .format(verb=sys.argv[1]))
    usage(1)
