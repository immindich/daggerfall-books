#!/usr/bin/python3

# The MIT License (MIT)
#
# Copyright (c) 2016 Isaiah Mindich
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import sys, struct
import json
import getopt

NEW_LINE = 0x00
SAME_LINE = 0x01
POSITION_PREFIX = 0xfb
FONT_PREFIX = 0xf9
FONT_SCRIPT = 0x02
FONT_NORMAL = 0x04
END_PAGE = 0xf6
CENTER = 0xfd

class Line:
    """The content and formatting data for a single line of text."""

    def __init__(self, prev = None):
        self.align = 'left'
        if prev:
            self.font = prev.font
        else:
            self.font = 'normal'
        self.text = ''
        self.xpos = 0
        self.ypos = 0

    def as_dict(self):
        """Convert to a dictionary, for easy JSON converesion."""
        return {'align': self.align,
                'font': self.font,
                'xpos': self.xpos,
                'ypos': self.ypos,
                'text': self.text}

class Page:
    """A page from a book.

    Books in Daggerfall are divided into pages.  If text goes off a
    page, it will not automatically go onto another page.  Instead, it
    will just go off the screen.

    """

    def __init__(self, data, offset):
        self.lines = []

        i = offset
        line = Line()

        while data[i] != END_PAGE:
            if data[i + 1] == POSITION_PREFIX:
                if data[i] == NEW_LINE:
                    self.lines.append(line)
                    line = Line(line)
                    line.xpos = data[i + 2]
                    line.ypos = data[i + 3]
                i += 4
                continue
            elif data[i] == FONT_PREFIX:
                if data[i + 1] == FONT_SCRIPT:
                    line.font = 'script'
                else:
                    line.font = 'normal'
                i += 2
                continue
            elif data[i] == NEW_LINE:
                self.lines.append(line)
                line = Line(line)
            elif data[i] == CENTER:
                line.align = 'center'
            else:
                line.text += chr(data[i])
            i+= 1

        if line.text != '':
            self.lines.append(line)

    def serializable(self):
        """Return the data in a way that can be converted to JSON."""
        cur_line = None
        line_list = []

        for line in self.lines:
            if cur_line:
                if (cur_line['align'] == line.align and
                    cur_line['font'] == line.font and
                    cur_line['xpos'] == line.xpos and
                    cur_line['ypos'] == line.ypos):

                    if not isinstance(cur_line['text'], list):
                        cur_line['text'] = [cur_line['text']]

                    cur_line['text'].append(line.text)
                else:
                    line_list.append(cur_line)
                    cur_line = line.as_dict()
            else:
                cur_line = line.as_dict()

        if cur_line:
            line_list.append(cur_line)

        return line_list

class Book:
    """Represents a single book and its contents

    The Book class contains all the text and formatting of one book,
    along with methods for writing and reading that information
    to/from various formats.

    """

    def __init__(self):
        self.title = ""
        self.author = ""
        self.pages = []
        self.naughty = False
        self.price = 0
        self.unknowns = [0, 0, 0]

    def decode(self, in_file):
        """Decode a file in the original book format

        in_file must be a file object or at least something with a
        .read() method which returns all the data as bytes.  Files
        must be opened in binary mode, or there will be unicode errors
        when trying to read from them.

        """
        book_data = in_file.read()

        if len(book_data) < 238:
            sys.stderr.write("Error: file too short\n")
            sys.exit(1)

        self.title = book_data[:64].decode('utf-8').rstrip('\0')
        self.author = book_data[64:128].decode('utf-8').rstrip('\0')

        self.naughty = book_data[128:136] == b'naughty '
        self.price = struct.unpack('<I', book_data[224:228])[0]

        self.unknowns = list(struct.unpack('<HHH', book_data[228:234]))

        page_count = struct.unpack('<H', book_data[234:236])[0]

        page_offsets = [struct.unpack('<I', book_data[236 + 4 * i:
                                                      240 + 4 * i])[0]
                        for i in range(page_count)]

        for offset in page_offsets:
            self.pages.append(Page(book_data, offset))

    def print_text(self):
        """Print as plain text, losing some formatting"""
        for p in self.pages:
            for l in p.lines:
                print(l.text)

    def dump_json(self):
        """Return all the book data in JSON format"""
        book_dict = {}
        book_dict['title'] = self.title
        book_dict['author'] = self.author
        book_dict['pages'] = [p.serializable() for p in self.pages]
        book_dict['naughty'] = self.naughty
        book_dict['price'] = self.price
        book_dict['unknowns'] = self.unknowns

        return json.dumps(book_dict, indent = 4)

def usage(status = 0):
    info = """Usage: ./dfbook [OPTIONS] [FILE]
Options:
-h, --help: print this help
-f FORMAT: specify the output format:
\ttext: plain text
\tjson: a json object, containing all text and formatting info
"""
    sys.stderr.write(info)
    sys.exit(status)

def print_exception(e):
    sys.stderr.write("Error: {error}\n".format(error=e))

def start():
    try:
        flags, args = getopt.getopt(sys.argv[1:], 'hf:', ['help'])
    except getopt.GetoptError as e:
        print_exception(e)
        usage(1)

    if len(args) > 1:
        sys.stderr.write("Error: too many arguments\n")
        usage(1)

    output_format = 'text'
    in_file = sys.stdin.buffer

    for opt, val in flags:
        if opt in ('-h', '--help'):
            usage()
        elif opt == '-f':
            output_format = val
        else:
            sys.stderr.write("Error: unrecognized option\n")
            usage(1)

    if len(args) == 1:
        try:
            in_file = open(args[0], 'rb')
        except IOError as e:
            print_exception(e)
            sys.exit(1)

    book = Book()
    book.decode(in_file)

    if output_format == 'text':
        book.print_text()
    elif output_format == 'json':
        print(book.dump_json())

start()
